---
title: insecure deserialization
description: 
author: doxawahebi
date: 2025-02-25 15:39:00 +0900
categories: [web, insecure deserialization]
tags: [web, insecure deserialization, hacking, portswigger]     # TAG names should always be lowercase
pin: false
math: false
mermaid: false
---

## Overview(or {{title}})
---
이번 시간에는 Insecure deserialization이 무엇이고 이공격이 잠재적으로 웹사이트에 어떤 심각한 위험을 끼칠 수 있는 알아보겠습니다. PHP, JAVA, Ruby 역직렬화를 통해 어떤 전형적인 시나리오가 있는지 살펴보겠습니다.



## What is serialization?
---
직렬화는 복잡한 data structures(object와 field와 같은 것)를 순차적인 바이트 스트림으로 받거나 전송할 수 있는 더 단순한(flatter) 형태로 변하는 것을 말합니다.

직렬화를 하면 다음과 같은 것을 간단하게 수행할 수 있습니다.

- 복잡한 데이터를 다른 프로세스의 메모리나 파일, DB에 write 할 수 있습니다.
- 네트워크나 애플리케이션의 구성 요소들끼리 또는 API 호출할 때 복잡한 데이터를 쉽게 보내거나 할 수 있습니다.

직렬화를 할 때 중요한 것은 **객체의 상태 또한 유지된다는 것입니다.** 다르게 말하면 객체들의 attribute들은 할당된 값과 함께 보존됩니다.

### Serialization vs deserialization
---
역직렬화는 바이트 스트림을 직렬화되었을 때와 정확히 같은 상태이고 original 객체와 완전히 기능적으로 동일한 replica로 복구하는 과정을 말합니다. 이 과정 덕분에 웹 사이트의 로직은 역직렬화된 객체를 다른 객체들와 같이 상호작용할 수 있게 됩니다.


많은 프로그래밍 언어들은 자체적으로 직렬화를 지원합니다. 이 직렬화를 지원하는 방식은 언어마다 다릅니다. 어떤 언어는 객체들을 바이너리 형태로 직렬화할 수 도 있고 단순히 사람한테 친숙한 문자열 형태일 수 도 있습니다.

주의할 점이 하나있는데 객체는 자신이 갖고 있는 모든 속성을 직렬화하기 때문에 객체의 **private fields 또한 데이터 스트림에 저장된다는 것 입니다.**
직렬화되고 싶지 않은 필드는 선언할 때 `transient`라고 암시적으로 마크해주어야합니다.

다른 언어에서는 marshalling(Ruby) 또는 pickling(Python)이라는 단어가 존재하는데 모두 직렬화와 동일한 의미라고 생각하면 좋습니다.

## What is insecure deserialization?
---
**안전하지 않은 역직렬화는 유저가 컨트할 수 있는 데이터가 역직렬화 될 때 발생합니다.**  이것은 잠재적으로 공격자가 직렬화된 객체를 조작하는 것을 가능하게 하고 이는 **애플리케이션 코드에 해로운 데이터를 전달하는 것으로 이어집니다.** 

그리고 직렬화된 객체를 완전히 다른 객체로 대체하는 것도 가능합니다. 놀랍게도 **어떤 클래스의 객체인지 상관없이 모든 클래스의 객체들은 역직렬화되고 인스턴화 될 수 있습니다.**  이러한 이유로 insecure deserialization는 object injection 취약점이라고도 알려져 있습니다. 

예기치 못한 클래스의 객체가 예외를 발생한다고 해도 그때쯤이면 이미 피해가 입은 뒤 입니다. 많은 역직렬화 기반 공격은 **역직렬화가 끝나기 전에 끝나있습니다.**  이는 다시 말하자면 악성 객체가 웹 사이트와 기능적으로 상호작용하지 않아도 **역직렬화 과정 그 자체가 공격에 사용될 수 있다는 것을 의미합니다.**
이러한 이유로 strongly typed language라도 이 테크닉에 취약할 수 있습니다.

## How do insecure deserialization vulnerabilities arise?
---
이 취약점은 user-controllable data가 역직렬화 되기 때문에 발생합니다. 그러므로 user input은 절대 역직렬화되어서는 안 됩니다.

때떄로 웹 사이트 소유자는 역직렬화된 데이터 대한 추가적인 검증을 구현했기 때문에 안전하다고 생각합니다. 하지만 이러한 접근은 별 효과가 없습니다. 왜냐하면 모든 상황에 대한 검증을 구현하는 것은 사실상 불가능하기 때문입니다. 또한 이러한 검증은 직렬화 후 데이터를 검증하는데 의존하기 때문에 직렬화 프로세스 자체가 취약할 수 있다는 것을 생각해보면 결점이 많고 공격을 방어하기에는 이미 너무 늦었다..

역직렬화된 객체가 신뢰할 수 있다고 가정하기 때문에 발생하는 경우도 있습니다. 특히 이진 형태 직렬화를 사용하는 언어들을 사용할 때 개발자들은 데이터를 효과적으로 조작하거나 읽을 수 없다고 생각합니다. 하지만 더 많은 노력이 필요할 수도 있지만 결론적으로 문자열 기반 포맷와 같은 방식으로 악용할 수 있습니다.

현대 웹 사이트는 많은 종속성들 갖고 있으며 이를 통해 역직렬화 기반 공격을 할 수도 있습니다. 방대한 양의 클래스와 메서드는 안전하게 관리하기 어렵기에 악의적인 데이터에 의해 어떤 메서드가 호출될 수 있을 지 예상하기 어렵습니다. 이는 공격자가 **메서드 호출을 chain을 만들듯이 길게 하여 예상치 못하게 초기 소스와 완전히 관련없는 싱크로 데이터를 전달할 수 있습니다.** 따라서 악성 데이터의 흐름을 예상하고 모든 잠재적인 구멍을 막는 것은 불가능합니다.

요약하면 신뢰할 수 없는 입력을 완전히 안전하게 역직렬화하는 것은 불가능하다는 것 입니다.


## What is the impact of insecure deserialization?
---
insecure deserialization의 영향으로는 attack surface가 굉장히 증가하는 진입점을 제공합니다. 기존 애플리케이션 코드를 악의적인 방식으로 재사용할 수 있으며 RCE와 같은 수많은 취약점을 초래할 수 있습니다.


## How to exploit insecure deserialization vulnerabilities
---

//




## How to prevent insecure deserialization vulnerabilities
---
기본적으로 사용자 입력을 역직렬화하지 않습니다. 

만약 이게 불가피하다면 디지털 서명을 통한 데이터의 무결성을 검증하는 방법을 구현합니다. 그리고 가장 중요한 것은 **모든 검증은 역직렬화 프로세스를 수행하기 전에 이루어져야합니다.** 그렇지 않다면 이 모든 과정은 의미가 없습니다.

가능하다면 일반적인 역직렬화 기능을 사용하지 않는 것도 하나의 방법입니다.(?) 최소한 어떤 필드가 노출되는지 제어할 수 있도록 클래스별로 직렬화 메서드를 만듭니다.

마지막으로 역직렬화 취약점은 가젯 체인의 존재가 아닌 **사용자 입력의 역직렬화 때문에** 발생한다는 점을 기업하십시오. 테스트 중 식별한 모든 가젯 체인을 없애기 위한 노력을 하지말라는 이야기입니다.

공개적으로 문서화된 메모리 취약점 또한 요인이 되어 애플리케이션늘 취약하게 만들 수도 있습니다.

